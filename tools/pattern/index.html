<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Buffer Overflow Pattern Generator & Offset Finder</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-color: #12121e;
    --container-bg: rgba(30, 32, 48, 0.7);
    --text-primary: #f0f0f0;
    --text-secondary: #a0a0b0;
    --border-color: rgba(255, 255, 255, 0.1);
    --input-bg: rgba(0, 0, 0, 0.2);
    --input-border: #444;
    --accent-primary: #667eea;
    --accent-secondary: #764ba2;
    --success-bg: rgba(46, 213, 115, 0.1);
    --success-border: rgba(46, 213, 115, 0.5);
    --success-text: #2ed573;
    --error-bg: rgba(255, 71, 87, 0.1);
    --error-border: rgba(255, 71, 87, 0.5);
    --error-text: #ff4757;
  }
  
  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    margin: 0;
    padding: 20px;
    background: var(--bg-color);
    background-image: radial-gradient(circle at top right, rgba(118, 75, 162, 0.2), transparent 40%),
                      radial-gradient(circle at bottom left, rgba(102, 126, 234, 0.2), transparent 40%);
    color: var(--text-primary);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .container {
    max-width: 1200px;
    width: 100%;
    background: var(--container-bg);
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    padding: 30px;
    margin: 20px;
    border: 1px solid var(--border-color);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
  }

  h1 {
    font-size: 28px;
    margin-bottom: 8px;
    color: #ffffff;
    text-align: center;
    font-weight: 700;
  }
  .small {
    font-size: 14px;
    color: var(--text-secondary);
    text-align: center;
    margin-bottom: 25px;
  }
  
  label {
    display: block;
    margin-top: 15px;
    font-weight: 600;
    color: var(--text-secondary);
    margin-bottom: 8px;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  input[type=number], input[type=text], textarea {
    width: 100%;
    padding: 12px;
    margin-top: 0;
    border-radius: 8px;
    background: var(--input-bg);
    border: 1px solid var(--input-border);
    font-size: 16px;
    color: var(--text-primary);
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
  }
  input[type=number]:focus, input[type=text]:focus, textarea:focus {
    outline: none;
    border-color: var(--accent-primary);
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
  }
  textarea {
    resize: vertical;
    min-height: 90px;
    font-family: inherit;
  }

  button {
    margin-top: 10px;
    padding: 10px 16px;
    border-radius: 8px;
    border: none;
    background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
    color: white;
    cursor: pointer;
    font-weight: 600;
    font-size: 15px;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }
  button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
  }
  button:active {
    transform: translateY(0);
  }

  .row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
  }
  @media (max-width: 768px) {
    .row {
      grid-template-columns: 1fr;
    }
  }

  pre {
    white-space: pre-wrap;
    word-break: break-all;
    background: rgb(39, 41, 56); /* Koyu kod bloğu */
    padding: 16px;
    border-radius: 8px;
    border: 1px solid var(--input-border);
    max-height: 320px;
    overflow: auto;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    color: #f0f0f0;
  }
  .controls {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: 10px;
  }

  #findResult {
    margin-top: 15px;
    font-size: 15px;
  }
  #findResult .success {
    background: var(--success-bg);
    border: 1px solid var(--success-border);
    color: var(--success-text);
    padding: 12px;
    border-radius: 8px;
  }
  #findResult .success strong {
    color: #ffffff; /* Offset'i daha görünür yap */
  }
  #findResult .success .small-note {
    font-size: 13px;
    color: var(--text-secondary);
    margin-top: 8px;
    opacity: 0.8;
  }
  #findResult .error {
    background: var(--error-bg);
    border: 1px solid var(--error-border);
    color: var(--error-text);
    padding: 12px;
    border-radius: 8px;
  }

</style>
</head>
<body>
<div class="container">
<h1>Pattern Generator & Offset Finder</h1>
<div class="small">Metasploit / pwntools tarzı cyclic pattern üretir ve debugger'da gördüğün register/hex için offset hesaplar.</div>

<label for="length">Pattern uzunluğu (bytes)</label>
<input id="length" type="number" value="30" min="1" max="100000"/>

<label for="charset">Charset sıralaması (her grup ayrı satırda)</label>
<textarea id="charset" rows="3">ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789</textarea>

<div>
  <label>Pattern oluştur</label>
  <div class="controls">
    <button id="genBtn">Generate</button>
    <button id="copyPatternBtn">Copy</button>
  </div>
  <pre id="patternOut"></pre>
</div>

<div style="margin-top: 25px;">
  <label for="probe">Offset bul (register/hex veya ascii)</label>
  <input id="probe" type="text" placeholder="Örnek: 0x41326241 veya 41 32 62 41 veya Aa1"/>
  <div class="controls">
    <button id="findBtn">Find offset</button>
    <button id="findRawBtn">Find raw (case sensitive)</button>
  </div>
  <div id="findResult"></div>
</div>
</div>

<script>

function buildCharsetRows(textareaValue) {
  return textareaValue.split(/\r?\n/).map(s => s.trim()).filter(Boolean).map(s => [...s]);
}

function generatePattern(length, rows) {
  if (rows.length === 0) return '';
  const counts = rows.map(r => r.length);
  const indexes = new Array(rows.length).fill(0);
  let out = '';
  while (out.length < length) {
    let token = '';
    for (let i=0;i<rows.length;i++) token += rows[i][indexes[i]];
    out += token;
    let pos = rows.length-1;
    while (pos >=0) {
      indexes[pos]++;
      if (indexes[pos] < counts[pos]) break;
      indexes[pos] = 0;
      pos--;
    }
    if (pos < 0) { /* wrapped */ }
    if (token.length === 0) break;
  }
  return out.slice(0, length);
}

function hexToBytes(hexStr) {
  hexStr = hexStr.replace(/^0x/i,'').replace(/[^0-9a-fA-F]/g,'');
  if (hexStr.length % 2 !== 0) return null;
  const bytes = [];
  for (let i=0;i<hexStr.length;i+=2) bytes.push(parseInt(hexStr.slice(i,i+2),16));
  return bytes;
}

function bytesToAscii(bytes) {
  return bytes.map(b => String.fromCharCode(b)).join('');
}

function reverseBytes(bytes) {
  return bytes.slice().reverse();
}

function findOffset(pattern, probeStr, options={caseSensitive:false}) {
  const normalizedPattern = options.caseSensitive ? pattern : pattern.toLowerCase();
  const hexBytes = hexToBytes(probeStr);
  if (hexBytes) {
    const s1 = bytesToAscii(hexBytes);
    const s2 = bytesToAscii(reverseBytes(hexBytes));
    const p1 = options.caseSensitive ? s1 : s1.toLowerCase();
    const p2 = options.caseSensitive ? s2 : s2.toLowerCase();
    let idx = normalizedPattern.indexOf(p1);
    if (idx !== -1) return {offset: idx, interpretation: 'hex (big-endian) ascii', matched: s1};
    idx = normalizedPattern.indexOf(p2);
    if (idx !== -1) return {offset: idx, interpretation: 'hex (little-endian) ascii', matched: s2};
  }
  const probe = options.caseSensitive ? probeStr : probeStr.toLowerCase();
  const idx = normalizedPattern.indexOf(probe);
  if (idx !== -1) return {offset: idx, interpretation: 'raw ascii', matched: probeStr};
  return {offset: -1};
}

const genBtn = document.getElementById('genBtn');
const patternOut = document.getElementById('patternOut');
const lengthInput = document.getElementById('length');
const charsetTA = document.getElementById('charset');
const copyPatternBtn = document.getElementById('copyPatternBtn');
const probeInput = document.getElementById('probe');
const findBtn = document.getElementById('findBtn');
const findRawBtn = document.getElementById('findRawBtn');
const findResult = document.getElementById('findResult');

let lastPattern = '';

genBtn.addEventListener('click', ()=> {
  const len = parseInt(lengthInput.value) || 0;
  const rows = buildCharsetRows(charsetTA.value);
  if (rows.length === 0) { patternOut.textContent = ''; return; }
  const p = generatePattern(len, rows);
  lastPattern = p;
  patternOut.textContent = p;
  findResult.innerHTML = ''; // Temizle
});


copyPatternBtn.addEventListener('click', async ()=> {
  if (!lastPattern) { genBtn.click(); }
  try {
    await navigator.clipboard.writeText(lastPattern);
    copyPatternBtn.textContent = 'Kopyalandı ✓';
    setTimeout(()=> copyPatternBtn.textContent = 'Copy', 1200);
  } catch(e) {
    alert('Clipboard erişimi başarısız: '+e);
  }
});

function handleFindClick(isCaseSensitive) {
  if (!lastPattern) { genBtn.click(); }
  const probe = probeInput.value.trim();
  if (!probe) { 
    findResult.innerHTML = `<div class="error">Lütfen bir değer girin.</div>`;
    return;
  }
  
  const res = findOffset(lastPattern, probe, {caseSensitive: isCaseSensitive});
  
  if (res.offset >= 0) {
    let resultHtml = `<div class="success">
                        <div><strong>Offset:</strong> ${res.offset} (0-based)</div>
                        <div><strong>Interpretation:</strong> ${res.interpretation}</div>`;
    if (!isCaseSensitive) {
      resultHtml += `<div class="small-note">örn: padding = 'A'.repeat(${res.offset}) + [EIP/RIP]</div>`;
    }
    resultHtml += `</div>`;
    findResult.innerHTML = resultHtml;
  } else {
    const sensitiveText = isCaseSensitive ? ' (case-sensitive arandı)' : '';
    findResult.innerHTML = `<div class="error">Pattern içinde bulunamadı${sensitiveText}.</div>`;
  }
}

findBtn.addEventListener('click', () => handleFindClick(false));
findRawBtn.addEventListener('click', () => handleFindClick(true));

genBtn.click();
</script>
</body>
</html>